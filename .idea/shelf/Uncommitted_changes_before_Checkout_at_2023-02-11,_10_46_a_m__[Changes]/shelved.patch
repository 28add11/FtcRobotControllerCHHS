Index: TeamCode/src/main/java/org/firstinspires/ftc/teamcode/PoleDetectionOpMode.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>/*\n * Copyright (c) 2019 OpenFTC Team\n *\n * Permission is hereby granted, free of charge, to any person obtaining a copy\n * of this software and associated documentation files (the \"Software\"), to deal\n * in the Software without restriction, including without limitation the rights\n * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n * copies of the Software, and to permit persons to whom the Software is\n * furnished to do so, subject to the following conditions:\n *\n * The above copyright notice and this permission notice shall be included in all\n * copies or substantial portions of the Software.\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\n * SOFTWARE.\n */\n\npackage org.firstinspires.ftc.teamcode;\n\nimport com.qualcomm.robotcore.eventloop.opmode.LinearOpMode;\nimport com.qualcomm.robotcore.eventloop.opmode.TeleOp;\n\nimport org.firstinspires.ftc.robotcore.external.hardware.camera.WebcamName;\nimport org.opencv.core.Mat;\nimport org.opencv.core.Core;\nimport org.opencv.core.Scalar;\nimport org.opencv.core.MatOfPoint;\nimport org.opencv.imgproc.Imgproc;\nimport org.opencv.core.MatOfPoint2f;\nimport org.openftc.easyopencv.OpenCvCamera;\nimport org.openftc.easyopencv.OpenCvCameraFactory;\nimport org.openftc.easyopencv.OpenCvCameraRotation;\nimport org.openftc.easyopencv.OpenCvPipeline;\nimport org.openftc.easyopencv.OpenCvWebcam;\n\n@TeleOp\npublic class PoleDetectionOpMode extends LinearOpMode\n{\n    OpenCvWebcam webcam;\n\n    @Override\n    public void runOpMode()\n    {\n        /*\n         * Instantiate an OpenCvCamera object for the camera we'll be using.\n         * In this sample, we're using a webcam. Note that you will need to\n         * make sure you have added the webcam to your configuration file and\n         * adjusted the name here to match what you named it in said config file.\n         *\n         * We pass it the view that we wish to use for camera monitor (on\n         * the RC phone). If no camera monitor is desired, use the alternate\n         * single-parameter constructor instead (commented out below)\n         */\n        int cameraMonitorViewId = hardwareMap.appContext.getResources().getIdentifier(\"cameraMonitorViewId\", \"id\", hardwareMap.appContext.getPackageName());\n        webcam = OpenCvCameraFactory.getInstance().createWebcam(hardwareMap.get(WebcamName.class, \"Webcam 1\"), cameraMonitorViewId);\n\n        // OR...  Do Not Activate the Camera Monitor View\n        //webcam = OpenCvCameraFactory.getInstance().createWebcam(hardwareMap.get(WebcamName.class, \"Webcam 1\"));\n\n        /*\n         * Specify the image processing pipeline we wish to invoke upon receipt\n         * of a frame from the camera. Note that switching pipelines on-the-fly\n         * (while a streaming session is in flight) *IS* supported.\n         */\n        webcam.setPipeline(new SamplePipeline());\n\n        /*\n         * Open the connection to the camera device. New in v1.4.0 is the ability\n         * to open the camera asynchronously, and this is now the recommended way\n         * to do it. The benefits of opening async include faster init time, and\n         * better behavior when pressing stop during init (i.e. less of a chance\n         * of tripping the stuck watchdog)\n         *\n         * If you really want to open synchronously, the old method is still available.\n         */\n        webcam.setMillisecondsPermissionTimeout(5000); // Timeout for obtaining permission is configurable. Set before opening.\n        webcam.openCameraDeviceAsync(new OpenCvCamera.AsyncCameraOpenListener()\n        {\n            @Override\n            public void onOpened()\n            {\n                /*\n                 * Tell the webcam to start streaming images to us! Note that you must make sure\n                 * the resolution you specify is supported by the camera. If it is not, an exception\n                 * will be thrown.\n                 *\n                 * Keep in mind that the SDK's UVC driver (what OpenCvWebcam uses under the hood) only\n                 * supports streaming from the webcam in the uncompressed YUV image format. This means\n                 * that the maximum resolution you can stream at and still get up to 30FPS is 480p (640x480).\n                 * Streaming at e.g. 720p will limit you to up to 10FPS and so on and so forth.\n                 *\n                 * Also, we specify the rotation that the webcam is used in. This is so that the image\n                 * from the camera sensor can be rotated such that it is always displayed with the image upright.\n                 * For a front facing camera, rotation is defined assuming the user is looking at the screen.\n                 * For a rear facing camera or a webcam, rotation is defined assuming the camera is facing\n                 * away from the user.\n                 */\n                webcam.startStreaming(320, 240, OpenCvCameraRotation.UPRIGHT);\n            }\n\n            @Override\n            public void onError(int errorCode)\n            {\n                /*\n                 * This will be called if the camera could not be opened\n                 */\n            }\n        });\n\n        telemetry.addLine(\"Waiting for start\");\n        telemetry.update();\n\n        /*\n         * Wait for the user to press start on the Driver Station\n         */\n        waitForStart();\n\n        while (opModeIsActive())\n        {\n            /*\n             * Send some stats to the telemetry\n             */\n            telemetry.addData(\"Frame Count\", webcam.getFrameCount());\n            telemetry.addData(\"FPS\", String.format(\"%.2f\", webcam.getFps()));\n            telemetry.addData(\"Total frame time ms\", webcam.getTotalFrameTimeMs());\n            telemetry.addData(\"Pipeline time ms\", webcam.getPipelineTimeMs());\n            telemetry.addData(\"Overhead time ms\", webcam.getOverheadTimeMs());\n            telemetry.addData(\"Theoretical max FPS\", webcam.getCurrentPipelineMaxFps());\n            telemetry.update();\n\n            /*\n             * NOTE: stopping the stream from the camera early (before the end of the OpMode\n             * when it will be automatically stopped for you) *IS* supported. The \"if\" statement\n             * below will stop streaming from the camera when the \"A\" button on gamepad 1 is pressed.\n             */\n            if(gamepad1.a)\n            {\n                /*\n                 * IMPORTANT NOTE: calling stopStreaming() will indeed stop the stream of images\n                 * from the camera (and, by extension, stop calling your vision pipeline). HOWEVER,\n                 * if the reason you wish to stop the stream early is to switch use of the camera\n                 * over to, say, Vuforia or TFOD, you will also need to call closeCameraDevice()\n                 * (commented out below), because according to the Android Camera API documentation:\n                 *         \"Your application should only have one Camera object active at a time for\n                 *          a particular hardware camera.\"\n                 *\n                 * NB: calling closeCameraDevice() will internally call stopStreaming() if applicable,\n                 * but it doesn't hurt to call it anyway, if for no other reason than clarity.\n                 *\n                 * NB2: if you are stopping the camera stream to simply save some processing power\n                 * (or battery power) for a short while when you do not need your vision pipeline,\n                 * it is recommended to NOT call closeCameraDevice() as you will then need to re-open\n                 * it the next time you wish to activate your vision pipeline, which can take a bit of\n                 * time. Of course, this comment is irrelevant in light of the use case described in\n                 * the above \"important note\".\n                 */\n                webcam.stopStreaming();\n                //webcam.closeCameraDevice();\n            }\n\n            /*\n             * For the purposes of this sample, throttle ourselves to 10Hz loop to avoid burning\n             * excess CPU cycles for no reason. (By default, telemetry is only sent to the DS at 4Hz\n             * anyway). Of course in a real OpMode you will likely not want to do this.\n             */\n            sleep(100);\n        }\n    }\n\n    /*\n     * An example image processing pipeline to be run upon receipt of each frame from the camera.\n     * Note that the processFrame() method is called serially from the frame worker thread -\n     * that is, a new camera frame will not come in while you're still processing a previous one.\n     * In other words, the processFrame() method will never be called multiple times simultaneously.\n     *\n     * However, the rendering of your processed image to the viewport is done in parallel to the\n     * frame worker thread. That is, the amount of time it takes to render the image to the\n     * viewport does NOT impact the amount of frames per second that your pipeline can process.\n     *\n     * IMPORTANT NOTE: this pipeline is NOT invoked on your OpMode thread. It is invoked on the\n     * frame worker thread. This should not be a problem in the vast majority of cases. However,\n     * if you're doing something weird where you do need it synchronized with your OpMode thread,\n     * then you will need to account for that accordingly.\n     */\n    class SamplePipeline extends OpenCvPipeline\n    {\n        boolean viewportPaused;\n\n        /*\n         * NOTE: if you wish to use additional Mat objects in your processing pipeline, it is\n         * highly recommended to declare them here as instance variables and re-use them for\n         * each invocation of processFrame(), rather than declaring them as new local variables\n         * each time through processFrame(). This removes the danger of causing a memory leak\n         * by forgetting to call mat.release(), and it also reduces memory pressure by not\n         * constantly allocating and freeing large chunks of memory.\n         */\n\n        //Note: I have literally no clue what various qualities mats should have, I feel like you might want to make them a volatile but the docs do it this way so ¯\\_(ツ)_/¯\n\n        Mat poles = new Mat(); //Final output mat to be displayed on screen, THIS IS NOT DATA FOR THE OPMODE, OPMODE DATA WILL BE GATHERED IN THE PIPELINE!\n        Mat HSVsource = new Mat(); //HSV conversion of input mat\n        Mat hirearchy = new Mat(); //It needs this for some reason\n\n        @Override\n        public Mat processFrame(Mat input)\n        {\n            /*\n             * IMPORTANT NOTE: the input Mat that is passed in as a parameter to this method\n             * will only dereference to the same image for the duration of this particular\n             * invocation of this method. That is, if for some reason you'd like to save a copy\n             * of this particular frame for later use, you will need to either clone it or copy\n             * it to another Mat.\n             */\n\n\n            /* Basic documentation can be found at docs.opencv.org, however they are a bit hard to understand. If any help is needed reach out to 28+11#9929 On discord.\n             * \n             * If anyone is maintaining this repo in the future when I have left crecent please sub in your own discord tag.\n             *\n             */\n\n            //UNTESTED AND THE DOCS WERE BAD!!!!\n            Imgproc.cvtColor(input, HSVsource, Imgproc.COLOR_RGB2HSV); //Convert RGB colorspace of input into HSV\n\n            /* Change the Scalars to modify parameters. In HSV colorspace. First Scalar is min value, second is max */\n            Core.inRange(HSVsource, new Scalar(38, 32, 39), new Scalar(78, 100, 100), poles); //Looks at every pixel of HSVsource, sees if it is between the two scalars, 255 if it is, 0 if it isnt\n\n            java.util.List<MatOfPoint> contours = new java.util.ArrayList<MatOfPoint>();\n\n            Imgproc.findContours(poles, contours, hirearchy, Imgproc.RETR_TREE, Imgproc.CHAIN_APPROX_SIMPLE); //finds contours, meaning edges. should work in practice\n\n            MatOfPoint2f poly = new MatOfPoint2f();\n\n\n            for (MatOfPoint2f cont : contours) { //java makes no sense and I have no clue if this works but hey it should i hope haha... Nathaniel or Ewan please review this\n\n                    Imgproc.approxPolyDP(cont, poly, 0.1, true); //aproximates a polygon for the contours. the third argument is sensitivity, change if we have absurdly high polygon sides\n                    \n                    if (poly.size(4) == 4) {\n                        //do something...\n                        continue;\n                    }\n            }\n\n\n            /**\n             * NOTE: to see how to get data from your pipeline to your OpMode as well as how\n             * to change which stage of the pipeline is rendered to the viewport when it is\n             * tapped, please see {@link PipelineStageSwitchingExample}\n             */\n\n            return poles;\n        }\n\n        @Override\n        public void onViewportTapped()\n        {\n            /*\n             * The viewport (if one was specified in the constructor) can also be dynamically \"paused\"\n             * and \"resumed\". The primary use case of this is to reduce CPU, memory, and power load\n             * when you need your vision pipeline running, but do not require a live preview on the\n             * robot controller screen. For instance, this could be useful if you wish to see the live\n             * camera preview as you are initializing your robot, but you no longer require the live\n             * preview after you have finished your initialization process; pausing the viewport does\n             * not stop running your pipeline.\n             *\n             * Here we demonstrate dynamically pausing/resuming the viewport when the user taps it\n             */\n\n            viewportPaused = !viewportPaused;\n\n            if(viewportPaused)\n            {\n                webcam.pauseViewport();\n            }\n            else\n            {\n                webcam.resumeViewport();\n            }\n        }\n    }\n}
===================================================================
diff --git a/TeamCode/src/main/java/org/firstinspires/ftc/teamcode/PoleDetectionOpMode.java b/TeamCode/src/main/java/org/firstinspires/ftc/teamcode/PoleDetectionOpMode.java
--- a/TeamCode/src/main/java/org/firstinspires/ftc/teamcode/PoleDetectionOpMode.java	
+++ b/TeamCode/src/main/java/org/firstinspires/ftc/teamcode/PoleDetectionOpMode.java	
@@ -229,21 +229,20 @@
             /* Change the Scalars to modify parameters. In HSV colorspace. First Scalar is min value, second is max */
             Core.inRange(HSVsource, new Scalar(38, 32, 39), new Scalar(78, 100, 100), poles); //Looks at every pixel of HSVsource, sees if it is between the two scalars, 255 if it is, 0 if it isnt
 
-            java.util.List<MatOfPoint> contours = new java.util.ArrayList<MatOfPoint>();
+            java.util.List<MatOfPoint2f> contours = new java.util.ArrayList<MatOfPoint2f>();
 
             Imgproc.findContours(poles, contours, hirearchy, Imgproc.RETR_TREE, Imgproc.CHAIN_APPROX_SIMPLE); //finds contours, meaning edges. should work in practice
 
-            MatOfPoint2f poly = new MatOfPoint2f();
+            MatOfPoint2f approx = new MatOfPoint2f();
 
 
             for (MatOfPoint2f cont : contours) { //java makes no sense and I have no clue if this works but hey it should i hope haha... Nathaniel or Ewan please review this
 
-                    Imgproc.approxPolyDP(cont, poly, 0.1, true); //aproximates a polygon for the contours. the third argument is sensitivity, change if we have absurdly high polygon sides
-                    
-                    if (poly.size(4) == 4) {
-                        //do something...
-                        continue;
-                    }
+                Imgproc.approxPolyDP(cont, approx, Imgproc.arcLength(cont, true) * 0.02, true); //aproximates a polygon for the contours. the third argument is sensitivity, change if we have absurdly high polygon sides
+                long count = approx.total();
+                if (count == 5) {
+                    continue;
+
             }
 
 
